using System;
using System.Collections.Generic;
using System.Text;

/**
 * The following is adapted directly from Mojang sources and is
 * subject to Mojang copyright and restrictions.
 */

namespace NBToolkit
{
    public class MathHelper
    {
        private static float[] trigTable = new float[65536];

        static MathHelper ()
        {
            for (int i = 0; i < 65536; i++) {
                trigTable[i] = (float)Math.Sin(i * Math.PI * 2.0D / 65536.0D);
            }
        }

        public static float Sin (float angle)
        {
            return trigTable[((int)(angle * 10430.378F) & 0xFFFF)];
        }

        public static float Cos (float angle)
        {
            return trigTable[((int)(angle * 10430.378F + 16384.0F) & 0xFFFF)];
        }
    }
}

using System;
using System.Collections.Generic;
using System.Text;
using Substrate;

namespace NBToolkit
{
    public interface IGenerator
    {
        bool Generate (IBlockManager blockMan, Random rand, int x, int y, int z);
    }

    /**
     * This class is derived from Mojang sources, the algorithm in particular
     * is subject to Mojang copyright and restrictions.  Mathfix patch by
     * jaquadro.
     */

    public class NativeGenOre : IGenerator
    {
        private int _blockId = 0;
        private int _blockData = 0;
        private int _size = 0;

        private bool _mathFix = false;

        public NativeGenOre (int blockId, int size)
        {
            _blockId = blockId;
            _size = size;
        }

        public NativeGenOre (int blockId, int blockData, int size)
        {
            _blockId = blockId;
            _blockData = blockData;
            _size = size;
        }

        public bool MathFix
        {
            get
            {
                return _mathFix;
            }
            set
            {
                _mathFix = value;
            }
        }

        public bool Generate (IBlockManager blockMan, Random rand, int x, int y, int z)
        {
            float rpi = (float)(rand.NextDouble() * Math.PI);

            double x1 = x + 8 + MathHelper.Sin(rpi) * _size / 8.0F;
            double x2 = x + 8 - MathHelper.Sin(rpi) * _size / 8.0F;
            double z1 = z + 8 + MathHelper.Cos(rpi) * _size / 8.0F;
            double z2 = z + 8 - MathHelper.Cos(rpi) * _size / 8.0F;

            double y1 = y + rand.Next(3) + 2;
            double y2 = y + rand.Next(3) + 2;

            for (int i = 0; i <= _size; i++) {
                double xPos = x1 + (x2 - x1) * i / _size;
                double yPos = y1 + (y2 - y1) * i / _size;
                double zPos = z1 + (z2 - z1) * i / _size;

                double fuzz = rand.NextDouble() * _size / 16.0D;
                double fuzzXZ = (MathHelper.Sin((float)(i * Math.PI / _size)) + 1.0F) * fuzz + 1.0D;
                double fuzzY = (MathHelper.Sin((float)(i * Math.PI / _size)) + 1.0F) * fuzz + 1.0D;

                int xStart, yStart, zStart, xEnd, yEnd, zEnd;

                    xStart = (int)(xPos - fuzzXZ / 2.0D);
                    yStart = (int)(yPos - fuzzY / 2.0D);
                    zStart = (int)(zPos - fuzzXZ / 2.0D);

                    xEnd = (int)(xPos + fuzzXZ / 2.0D);
                    yEnd = (int)(yPos + fuzzY / 2.0D);
                    zEnd = (int)(zPos + fuzzXZ / 2.0D);
                

                for (int ix = xStart; ix <= xEnd; ix++) {
                    double xThresh = (ix + 0.5D - xPos) / (fuzzXZ / 2.0D);
                    if (xThresh * xThresh < 1.0D) {
                        for (int iy = yStart; iy <= yEnd; iy++) {
                            double yThresh = (iy + 0.5D - yPos) / (fuzzY / 2.0D);
                            if (xThresh * xThresh + yThresh * yThresh < 1.0D) {
                                for (int iz = zStart; iz <= zEnd; iz++) {
                                    double zThresh = (iz + 0.5D - zPos) / (fuzzXZ / 2.0D);
                                    if (xThresh * xThresh + yThresh * yThresh + zThresh * zThresh < 1.0D) {
                                        BlockRef block = blockMan.GetBlockRef(ix, iy, iz);
                                        if (block != null) {
                                            block.ID = _blockId;
                                            block.Data = _blockData;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return true;
        }
    }